function out = tdr_cross_time_decoder_analysis(figSaveDir, tbytDat_hAligned, y, varargin)
% Compare decoder generalizability across time: cosine angle & decoding accuracy
% between time bins using TDR-based logistic regression.

% ---- Parameters ----
p = inputParser;
p.addParameter('Epoch', [-0.5 4], @(v)isnumeric(v)&&numel(v)==2);
p.addParameter('Win', 0.100, @(v)isnumeric(v)&&isscalar(v)&&v>0);
p.addParameter('Step', 0.050, @(v)isnumeric(v)&&isscalar(v)&&v>0);
p.addParameter('Lambda', 1, @(v)isnumeric(v)&&isscalar(v)&&v>0);
p.addParameter('minSD', 1e-3, @(v)isnumeric(v)&&isscalar(v)&&v>0);
p.addParameter('minPerClass', 5, @(v)isnumeric(v)&&isscalar(v)&&v>=0);
p.addParameter('DoPlots', true, @(v)islogical(v)||ismember(v,[0 1]));

p.parse(varargin{:});
prm = p.Results;

% ---- Time window setup ----
tStart = prm.Epoch(1); tEnd = prm.Epoch(2);
win = prm.Win; step = prm.Step;
ctr = (tStart + win/2) : step : (tEnd - win/2);
nW = numel(ctr);
winBounds = [ctr(:)-win/2, ctr(:)+win/2];

% ---- Feature assembly ----
N = size(tbytDat_hAligned, 2);
K = size(tbytDat_hAligned{1,1},1);
Xw = cell(1,nW); validw = cell(1,nW);

for i = 1:nW
    lb = winBounds(i,1); ub = winBounds(i,2);
    X = nan(N, K);
    for n = 1:N
        t = tbytDat_hAligned{2,n};
        idx = t >= lb & t < ub;
        if any(idx)
            H = tbytDat_hAligned{1,n};
            X(n,:) = mean(H(:,idx), 2, 'omitnan')';
        end
    end
    Xw{i} = X;
    validw{i} = ~any(isnan(X),2);
end

% ---- Global z-scoring stats ----
Xstack = cat(1, Xw{:});
muG = mean(Xstack, 1, 'omitnan');
sdG = std(Xstack, 0, 1, 'omitnan');
sdG(sdG < prm.minSD) = prm.minSD;

% ---- Train classifiers at each time ----
Wz = nan(K, nW); b = nan(1,nW);
validTrials = false(N, nW);
for i = 1:nW
    X = Xw{i};
    valid = validw{i};
    v_hit = valid & (y(:)==1);
    v_cr  = valid & (y(:)==0);
    if sum(v_hit) < prm.minPerClass || sum(v_cr) < prm.minPerClass
        continue
    end
    Xz = (X(valid,:) - muG) ./ sdG;
    yv = y(valid);
    mdl = fitclinear(Xz, yv, 'Learner','logistic', 'Regularization','ridge', ...
        'Lambda', prm.Lambda, 'Solver','lbfgs', 'ClassNames',[0,1]);
    Wz(:,i) = mdl.Beta;
    b(i) = mdl.Bias;
    validTrials(valid,i) = true;
end

% Align decoder weights based on response period (e.g. 2â€“4s)
[Wz_aligned, flipSign] = align_decoder_signs(Wz, winCtrs, [2 4]);
b_aligned = b;
b_aligned(flipSign) = -b_aligned(flipSign); % sign flip must be applied here too

% ---- Cosine similarity and decoding accuracy across time ----
cosineSim = nan(nW, nW);
decAcc    = nan(nW, nW);

for i = 1:nW
    wi = Wz_aligned(:,i);
    if all(isnan(wi)), continue; end

    for j = 1:nW
        wj = Wz_aligned(:,j);
        if all(isnan(wj)), continue; end

        % --- robust cosine similarity (ignore NaNs; guard zero norms)
        mask = isfinite(wi) & isfinite(wj);
        if ~any(mask), continue; end
        ni = norm(wi(mask)); nj = norm(wj(mask));
        if ni==0 || nj==0, continue; end
        cosineSim(i,j) = dot(wi(mask), wj(mask)) / (ni * nj);

        % --- cross-time decoding: train at i (wi,b_aligned(i)), test at j
        Xtest = Xw{j};
        valid = validw{j} & validTrials(:,i);
        if ~any(valid), continue; end

        Xz_test = (Xtest(valid,:) - muG) ./ sdG;
        y_test  = y(valid);

        scores = Xz_test * wi + b_aligned(i);   % use aligned bias

        yhat   = scores > 0;
        decAcc(i,j) = mean(yhat == y_test);
    end
    fprintf("Completed cross-time evaluation for ", i)
end

% ---- Pack output ----
out = struct('Wz', Wz, 'Wz_aligned', Wz_aligned, 'b', b, 'b_aligned', b_aligned, ...
            'cosineSim', cosineSim, 'crossDecodingAcc', decAcc, 'winCtrs', ctr);

% ---- Plots ----
if prm.DoPlots
    figure; imagesc(ctr, ctr, cosineSim); axis xy equal tight;
    title('Cosine Similarity of Decoder Weights'); xlabel('Train Time'); ylabel('Test Time'); colorbar;

    figure; imagesc(ctr, ctr, decAcc); axis xy equal tight;
    title('Cross-temporal Decoding Accuracy'); xlabel('Train Time'); ylabel('Test Time'); colorbar;
end


%% % ---- Helper function ----
function [Wz_aligned, flipSign] = align_decoder_signs(Wz, ctr, refEpoch)
% Aligns decoder weights Wz across time bins based on a reference epoch
%   Wz       - K x T matrix of decoder weights (K: features, T: time bins)
%   ctr      - 1 x T vector of window centers (in seconds)
%   refEpoch - [start, end] reference period for sign alignment (e.g., [2, 4])

    T = size(Wz,2);
    Wz_aligned = Wz;
    flipSign = false(1, T);

    % Identify reference bins
    refIdx = find(ctr >= refEpoch(1) & ctr <= refEpoch(2));
    if isempty(refIdx)
        warning('No reference bins found in specified refEpoch.');
        return
    end

    % Compute reference vector (mean over ref bins)
    refVec = mean(Wz(:,refIdx), 2, 'omitnan');
    refVecNorm = norm(refVec(~isnan(refVec)));
    if refVecNorm == 0
        warning('Reference vector has zero norm; skipping alignment.');
        return
    end
    refUnit = refVec / refVecNorm;

    % Align each time bin
    for tt = 1:T
        w = Wz(:,tt);
        if all(isnan(w)), continue; end
        val = isfinite(w) & isfinite(refUnit);
        if ~any(val), continue; end
        cosSim = dot(w(val), refUnit(val)) / (norm(w(val)) * norm(refUnit(val)));
        if cosSim < 0
            Wz_aligned(:,tt) = -w;
            flipSign(tt) = true;
        end
    end
end

end
